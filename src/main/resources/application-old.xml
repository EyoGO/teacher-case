<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans.xsd
                             http://www.springframework.org/schema/context
                             http://www.springframework.org/schema/context/spring-context-4.0.xsd">


<!--    FLOW ПОЗБАВЛЕННЯ ВІД XML конфіга.
1. На початку у нас XML з <bean id="..." class="...">  <constructor-arg (ref|value)="(str2|${db.url})" /> </bean> - тобто усе в XML.
2. Далі, добавивши BPP (для процесінгу анотацій типу @Autowired, @Value,...) через явне додавання в XML біна
CommonAnnotationBeanPostProcessor або завдяки предефайнед <context:annotation-config/> позбуваємось ініціалізації бініва з
XML (тобто тепер параметри в <constructor-args.../>... інжектяться завдяки @Autowired над полями, АЛЕ ТЕПЕР КОНСТРУКТОР БЕЗ ПАРАМЕТРІВ ОБОВ'ЯЗКОВИЙ ДЛЯ ЦЬОГО,
тобто в XML все ще залишились оголошення бінів <bean class=...MyClass/>, але параметри заінжектяться з анотацій.
3. Додавання <context:component-scan base-package="com.eyogo"/> змусить спрінг сканувати компонети (класи з @Component) у вказаному пакеті
й все знайдене буде генеруватись як бін в спрінгу через ОДИН ЄДИНИЙ @Autowired конструктор (тепер усі поля final). Тобто всі свої класи тепер
треба помітити як @Component. NOTE: усі сторонні класи типу Spring та сторонні (де не можемо поставити анотацію) й усі класи
з кількома бінами (анотація одна на клас, відповідно створиться 1 бін відповідно конструктору) при цьому не можна створити!
Це буде можливо через Java based configuration.
Таким чином, у XML не залишилось нічого крім <context:component-scan base-package="com.eyogo"/>
4. -->

<!--    <bean id="str1" name="s1,s11,s111" class="java.lang.String">-->
<!--        <constructor-arg value="${db.url}"/>-->
<!--    </bean>-->
<!--    <bean id="str2" name="s2,s22,s222" class="java.lang.String">-->
<!--        <constructor-arg value="#{str1.toUpperCase()}"/>-->
<!--    </bean>-->
    <!--    name - аліаси (за ними теж можна шукати)-->
    <!--    В першу чергу шукається по ID, якщо по айді немає, то по значенях в мапі aliasMap (там знаходить ID)-->

    <!--    Через конструктор найкращий варіант, ще є фабричний метод і сеттери (проперті), але сеттери дають можливість
    зробити циклічну залежність (бо нам не обов'язково на початку передавати залежності в конструктор і далі ми можемо
    передати циклічність через сеттер). Сеттери краще юзати для опціональних залежностей-->

    <!--    Активація пропертіс файлів-->
<!--    <context:property-placeholder location="classpath:application.properties"/>-->
    <!--    <bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">-->
    <!--        <property name="locations" value="classpath:application.properties"/>-->
    <!--    </bean>-->

    <!--    !!!Активація процесінгу АНОТАЦІЙ - закоментована бо вона включена уже в component-scan активації!!!-->
    <!--<context:annotation-config/>--> <!-- фактично додає CommonAnnotationBeanPostProcessor й інші BPP і BFPP для обробки аннотацій-->
<!--    <bean class="org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"/>-->

<!--    <bean class="com.eyogo.http.repository.UnitDao"/>-->

    <!--    BPP мають 2 методи postProcess(Before|After)Initialization
    Вони використовуються для процесінгу анотацій над бінами по типу @Autowired - Приклад:
    bean.getDeclaredFields().foreach -> field.getAnnotations().isAnnotationPresent(Autowired.class) -> ReflectionUtils.makeAccessible(field); ReflectionUtils.setField(field, bean, beanToInject)
    Своєю чергою попередньо рахується умовно так (насправді складніше) beanToInject = applicationContext.getBean(field.getType()), а applicationContext прийшов завдяки інтерфейсу ApplicationContextAware, який реалізуємо в цьому BPP.

    !!!!!!!!!
    Негласне правило каже що не можна повертати видозмінені біни з Before ініціалізації, бо потім інший BPP у своєму Before отримає проксі у якого не буде анотацій.
    After же можна використовувати для повернення проксі, АЛЕ при звичайному використанні буде та ж проблема, що і в Before -
    наступний BPP отримає проксі без анотацій, а не оригінальний бін. Щоб уникати цього в BPP створюють щось на подобі Map<String, Class> - назва біна до класу біна,
    яка заповнюється в Before, де й фільтрується. Тобто буде перевірка в Before bean.getClass().isAnnotationPresent(Transaction.class) і якщо так - то додати в мапу.
    Далі After в першу чергу дивитиметься чи є вхідний бін в мапі - немає, то просто поверне те що на вхід, а якщо є, то додасть проксі методи саме оригінальному біну
    з мапи, А НЕ З ПАРАМЕТРА - в параметрі може бути проксі, а в мапі завжди оригінал, якому ми й підміняємо функціонал. Але виклик всередині method.invoke(bean, args),
    де bean - це вхідний параметр After (тобто зовнішній проксі), таким чином ми нашаровєм проксі. Приклад:
    Створили свої AuditingBPP та TransactionBPP (обидва додають функціональність навколо всіх методів класу - логи часу, транзакцію).
    Тепер порядок логів буде (залежно від порядку BPP): Audit Method, Transaction Opened, Method execution, Transaction Closed, Audit Closed.
    Це тому що проксі AuditingBPP, який вивів лог, а потім викликав invoke на вхідному проксі (який утворився на транзакційному) його After методу,
    це спричинило виклик проксі методу з TransactionBPP - вивід лога і виклик invoke вхідного (а у цього TransactionBPP вхідним біном був оригінал, тому це й буде кінцем ланцюга проксі).
    Все це завдяки нашаруванню проксі над проксі й в результаті фінальний проксі викликатиме оригінальний метод всередині.-->


    <!--    @Qualifier потрібен лише для явного вказування. Але можна просто назвати поле/параметр.. так як і айдішка біна, тоді @Qualifier неявно буде відповідати назві поля - тобто біна.
    
    @Autowired це спрінгова анотація з більшими можливостями ніж @Resource з JSR.
    Вона не має кваліфаєра всередині, але може ставитись на такі типи куди @Resource не ставиться і що круто - інжектити в філд багато бінів одного типу.
    Достатньо просто вписати @Autowire List<String> strinBeans - і це поле заінжектить всі стрінгові біни.-->

<!-- Це скорочення включає в себе аnnotation-config скорочення, тому закоментуємо його.
Завдяки цьому спрінг піде шукати все під базовим пакетом, а саме класи з анотацією @Component і створюватиме з них біни.
Завдяки цьому, тепер немає необхідності писти біни, які ми хочемо у програмі в xml файлі (<bean class="com.eyogo.http.repository.UnitDao"/>), достатньо помітити клас як @Component.
Без цього анотації працювали, АЛЕ необхідно було писати який бін створити в xml файл (без ініціалізацій - використовуватиметься конструктор за замовчуванням, а далі поля заповнятимуться @Autowire над полями/методами).
Тепер же у нас будуть @Component зіскановані й використовуватиметься один єдиний @Autowired конструктор.-->
<!--    <context:component-scan base-package="com.eyogo"/>-->


<!--    Далі весь цей файл можна замінити Java-based конфігом. Для цього використовується @Configuration анотація над класом, як правило config.***Configuration.
Ця анотація обробляється BFPP з <context:annotation-config/> або з <context:component-scan base-package="com.eyogo"/>. Таким чином ми поки змушені мати XML ще.
Далі можна позбутись <context:property-placeholder location="classpath:application.properties"/> через анотацію @PropertyResource("classpath:application.properties").
Залишилось позбутись component-scan. Для цього ставимо анотацію @ComponentScan - у неї є всі ті ж параметри що і в XML. АЛЕ ТЕПЕР ПРОГРАМА НЕ ПРАЦЮВАТИМЕ, бо
в нашому main методі ми ініціалізуємо контекст через new ClassPathXmlApplicationContext("application.xml"), а треба перевизначити це і робити з Java-based -
-->
</beans>